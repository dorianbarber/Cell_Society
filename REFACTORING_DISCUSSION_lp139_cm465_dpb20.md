
The most basic refactoring that we did was to replace many of the “magic values” in our code with named constants. This made the code much more readable, though we left some magic values in because we anticipate having to make a lot of changes in our display in the next few days. Along with that, we refactored to make our code more uniformly styled and as readable as possible based purely on naming and stylistic conventions. 

A more complex kind of refactoring that we did was to change the behavior of our getNeighbors() method. We anticipate having to change the parameters of what counts as a neighbor regularly with the new additions we plan to make (i.e. toroidal grid, different cell shapes, etc.), and our getNeighbors() methods were within each cell, meaning that every cell had to have access to the grid and to calculate its own neighbors. This created a lot of duplicate code, as each method was using the same general logic to compute its neighbors, even though the specific number and position of relevant neighbors were different. To solve this, we implemented a NeighborFinder class which contains several different implementations of the getNeighbors() method, all with different parameters that define the different behavior of each one. That simplified our existing code immensely because with all of the methods in the same place, we could easily see that most of the methods were just getting subsets of one another, so we allowed some methods to call one another, which cut down on repeated code.

Another refactor that was necessary came in the form in compartmentalizing  the WatorCell update methods. After running the design analysis tool, we realized that the complexity of the watorcell rules lead to a cognitive complexity much higher than necessary. Moving all of these rules into different methods reduced duplicity and made it much simpler to understand the code.

An additional refactor was centered around the Grid class. In this section of code the immediate problem stemmed from the fact that there were a significant number of other classes that rely on the 2-dimensional grid. To be more specific it is an arraylist of arraylists of cell model classes. When passing the grid off to other classes the previous method involved simply returning the instance variable which held that data structure. We implemented the Collections.unmodifiableList to return an unmodifiable version of that data structure. This however, posed new problems with the way we declared the arraylists and when we declared the list. Essentially all method return types and parameters relating to the 2D structure would be a list of lists of cellmodels. At instantiating and creation of the grid structure we used the new keyword with ArrayLists to make the list workable. This also follows principles of OOP better by becoming much more flexible (i.e. if we wanted to change our implementation to a LinkedList for some incomprehensible reason, it would be much easier to do so with this version). 



